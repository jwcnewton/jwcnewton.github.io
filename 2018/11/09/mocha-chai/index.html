<!DOCTYPE html><html><head><meta name="generator" content="Hexo 3.8.0"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="author" content="Jonathan Newton"><link rel="alternative" href="/atom.xml" title="jwcnewton" type="application/atom+xml"><link rel="icon" href="/favicon.ico"><title>JavaScript unit testing with Mocha, and Chai. - jwcnewton</title><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="/js/fancybox/jquery.fancybox.min.css"><!--[if lt IE 9]><script>(function(a,b){a="abbr article aside audio bdi canvas data datalist details dialog figcaption figure footer header hgroup main mark meter nav output progress section summary template time video".split(" ");for(b=a.length-1;b>=0;b--)document.createElement(a[b])})()</script><![endif]--><script src="/js/jquery-3.1.1.min.js"></script><script src="/js/fancybox/jquery.fancybox.min.js"></script></head><body style="opacity:0"><header class="head"><h1 class="head-title u-fl"><a href="/">Jonathan Newton</a></h1><nav class="head-nav u-fr"><ul class="head-nav__list"><li class="head-nav__item"><a class="head-nav__link" href="/archives">POSTS</a></li></ul></nav></header><main class="main"><article class="post"><header class="post__head"> <time class="post__time" datetime="2018-11-09T20:47:25.000Z">November 9, 2018</time><h1 class="post__title"><a href="/2018/11/09/mocha-chai/">JavaScript unit testing with Mocha, and Chai.</a></h1><div class="post__main echo"><p>JavaScript unit testing is essential.<br>When I hear something is untested I think vulnerable, or technical debt and you should to. </p>
<p>This is run down of mocha and chai pulled from a presentation I did at the Hydrographic office.</p>
<h1 id="Mocha"><a href="#Mocha" class="headerlink" title="Mocha"></a>Mocha</h1><p>Mocha is a testing library for Node.js, created to be a simple, extensible, and fast testing suite. It’s used for unit and integration testing, and it’s a great candidate for BDD (Behavior Driven Development).</p>
<p>Mocha gives us the ability to describe the features that we are implementing by giving us a describe function that encapsulates our expectations. </p>
<ul>
<li>Asynchronous, Synchronous</li>
<li>Dynamic Test Generation</li>
<li>Custom Reporters</li>
<li>Retry Policies</li>
<li>Test Analytics </li>
<li>Test interface styles</li>
</ul>
<h1 id="Mocha-Interfaces"><a href="#Mocha-Interfaces" class="headerlink" title="Mocha Interfaces"></a>Mocha Interfaces</h1><h2 id="BDD-Interface"><a href="#BDD-Interface" class="headerlink" title="BDD Interface"></a>BDD Interface</h2><p>The first argument is a simple string that describes the feature, while the second argument is a function that represents the body of the description.</p>
<p>The describe is your test suite,<br>The context is the body of your test suite,<br>The it is the actually test.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> should = <span class="built_in">require</span>(<span class="string">'chai'</span>).should()</span><br><span class="line"><span class="keyword">let</span> jam = &#123; <span class="attr">types</span>: [ <span class="string">'Blueberry'</span>, <span class="string">'Strawberry'</span>, <span class="string">'Raspberry'</span>, <span class="string">'Plum'</span> ] &#125;;</span><br><span class="line"></span><br><span class="line">describe(<span class="string">'Jam'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  before(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  &#125;);</span><br><span class="line">  </span><br><span class="line">  context(<span class="string">'Root'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  </span><br><span class="line">    it(<span class="string">'Should be an object'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      jam.should.be.an(<span class="string">'object'</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="TDD-Interface"><a href="#TDD-Interface" class="headerlink" title="TDD Interface"></a>TDD Interface</h2><p>Similar syntax to the BDD interface but the instead of context we have suite inside of a suite signalling an inner suite, all so instead of the ‘it’ syntax we have test it serves the same purpose just a bit more verbose</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> assert = chai.assert;</span><br><span class="line"><span class="keyword">let</span> jam = &#123; <span class="attr">types</span>: [ <span class="string">'Blueberry'</span>, <span class="string">'Strawberry'</span>, <span class="string">'Raspberry'</span>, <span class="string">'Plum'</span> ] &#125;;</span><br><span class="line"></span><br><span class="line">suite(<span class="string">'Jam'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  setup(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  &#125;);</span><br><span class="line">  </span><br><span class="line">  suite(<span class="string">'Root'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    </span><br><span class="line">    test(<span class="string">'Is an object'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      assert.isObject(jam, <span class="string">'Jam is an object'</span>); </span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="Qunit-Interface"><a href="#Qunit-Interface" class="headerlink" title="Qunit Interface"></a>Qunit Interface</h2><p>For those coming from QUnit to Mocha this is ideal.</p>
<p>QUnit favours moving out and nested suites into the same tab.<br>And your ‘suites’ look more like .net regions the runner will automatically group tests based on the the last declared suite </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> expect = chai.expect;</span><br><span class="line"><span class="keyword">let</span> jam = &#123; <span class="attr">types</span>: [ <span class="string">'Blueberry'</span>, <span class="string">'Strawberry'</span>, <span class="string">'Raspberry'</span>, <span class="string">'Plum'</span> ] &#125;;</span><br><span class="line"></span><br><span class="line">suite(<span class="string">'Jam'</span>);</span><br><span class="line"></span><br><span class="line">test(<span class="string">'Root'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  expect(jam).to.be.an(<span class="string">'object'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h1 id="Chai"><a href="#Chai" class="headerlink" title="Chai"></a>Chai</h1><p>Chai is an assertion library.</p>
<ul>
<li>BDD syntax</li>
<li>Integrates with test frameworks</li>
<li>Assertion styles</li>
</ul>
<p>Chai is not a framework it’s designed to work along side a framework, how you choose to run your tests or what technology you want to use is entirely up to you chai give you the option to keep you assertion library and your framework separate so if you wanted to change your framework you wouldn’t have to rewrite any of your tests, this is really powerful when we start looking at some of the plugins and async capability</p>
<h2 id="Chai-Styles"><a href="#Chai-Styles" class="headerlink" title="Chai Styles"></a>Chai Styles</h2><h2 id="Should-style"><a href="#Should-style" class="headerlink" title="Should style"></a>Should style</h2><p>Should allows you to chain result expectations whilst keeping the test assert clean and verbose.​ </p>
<p>The BDD styles are expect and should. </p>
<p>Both use the same chainable language to construct assertions, but they differ in the way an assertion is initially constructed.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> should = <span class="built_in">require</span>(<span class="string">'chai'</span>).should()</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> jam = &#123; <span class="attr">types</span>: [ <span class="string">'Blueberry'</span>, <span class="string">'Strawberry'</span>, <span class="string">'Raspberry'</span>, <span class="string">'Plum'</span> ] &#125;;</span><br><span class="line"></span><br><span class="line">jam.should.be.an(<span class="string">'object'</span>);</span><br><span class="line">jam.should.have.property(<span class="string">'types'</span>).with.lengthOf(<span class="number">4</span>);</span><br><span class="line">jam.types.should.be.an(<span class="string">'array'</span>);</span><br><span class="line">jam.types.should.be.an(<span class="string">'array'</span>).that.does.not.include(<span class="string">'Peanut Butter'</span>);</span><br></pre></td></tr></table></figure></p>
<h2 id="Expect-style"><a href="#Expect-style" class="headerlink" title="Expect style"></a>Expect style</h2><p>Expect covers the same functionality but it does a lot of the chaining for you.</p>
<p>You pass your test object into the expect then chain your result expectations.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> expect = chai.expect;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> jam = &#123; <span class="attr">types</span>: [ <span class="string">'Blueberry'</span>, <span class="string">'Strawberry'</span>, <span class="string">'Raspberry'</span>, <span class="string">'Plum'</span> ] &#125;;</span><br><span class="line"></span><br><span class="line">expect(jam).to.be.an(<span class="string">'object'</span>);</span><br><span class="line">expect(jam).to.have.property(<span class="string">'types'</span>).with.lengthOf(<span class="number">4</span>);</span><br><span class="line">expect(jam.types).to.be.an(<span class="string">'array'</span>);</span><br><span class="line">expect(jam.types).to.be.an(<span class="string">'array'</span>).that.does.not.include(<span class="string">'Peanut Butter'</span>);</span><br></pre></td></tr></table></figure>
<h2 id="Assert-style"><a href="#Assert-style" class="headerlink" title="Assert style"></a>Assert style</h2><p>This is a very common assertion style and you see it include with alot of frameworks mocha comes with its own assert library, qunit and Jasmine also use this style.</p>
<p>Assert is not as chainable as Should or Expect but can handle more complex assertions and is more like the syntax found in other libraries </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> assert = chai.assert;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> jam = &#123; <span class="attr">types</span>: [ <span class="string">'Blueberry'</span>, <span class="string">'Strawberry'</span>, <span class="string">'Raspberry'</span>, <span class="string">'Plum'</span> ] &#125;;</span><br><span class="line"></span><br><span class="line">assert.isObject(jam, <span class="string">'Jam is an object'</span>); </span><br><span class="line">assert.property(jam, <span class="string">'types'</span>);</span><br><span class="line">assert.isArray(jam.types, <span class="string">'Jam types is an array'</span>);</span><br><span class="line">assert.lengthOf(jam.types, <span class="number">4</span>, <span class="string">'4 items in array'</span>);</span><br><span class="line">assert.doesNotHaveAnyKeys(jam.types, <span class="string">'Peanut Butter'</span>);</span><br></pre></td></tr></table></figure>
<h1 id="Stubs-and-Spies"><a href="#Stubs-and-Spies" class="headerlink" title="Stubs and Spies"></a>Stubs and Spies</h1><p>Testing functions that return jquery elements, http request, data, asynchronous promises, ect… would be pretty difficult without stubs and spies, they allow us to force a response or watch interactions between objects </p>
<h2 id="Spies"><a href="#Spies" class="headerlink" title="Spies"></a>Spies</h2><p>A test spy is a function that records arguments, return value, the value of this and exception thrown (if any) for all its calls. There are two types of spies: Some are anonymous functions, while others wrap methods that already exist in the system under test.</p>
<h2 id="When-to-Use-Spies"><a href="#When-to-Use-Spies" class="headerlink" title="When to Use Spies?"></a>When to Use Spies?</h2><p>Spies are used to get information about function calls. For example, a spy can tell us how many times a function was called, what arguments each call had, what values were returned, what errors were thrown, etc.</p>
<p>As such, a spy is a good choice whenever the goal of a test is to verify something happened. Combined with Sinon’s assertions, we can check many different results by using a simple spy.</p>
<h2 id="Stubs"><a href="#Stubs" class="headerlink" title="Stubs"></a>Stubs</h2><p>Test stubs are functions with pre-programmed behaviour.</p>
<p>They support the all of the Chai assertion library in addition to methods which can be used to alter the stub’s behaviour.</p>
<p>As spies, stubs can be either anonymous, or wrap existing functions. When wrapping an existing function with a stub, the original function is not called.</p>
<h2 id="When-to-Use-Stub"><a href="#When-to-Use-Stub" class="headerlink" title="When to Use Stub?"></a>When to Use Stub?</h2><p>Control a method’s behavior from a test to force the code down a specific path. Examples include forcing a method to throw an error in order to test error handling.</p>
<p>When you want to prevent a specific method from being called directly (possibly because it triggers undesired behavior, such as a XMLHttpRequest or similar).</p>
<h1 id="Plugins"><a href="#Plugins" class="headerlink" title="Plugins"></a>Plugins</h1><p>Plugins are lightweight bolt-on’s for chai that help extend functionality without changing the assert chains.</p>
<p>Plugins give you continuity across your entire test suite.</p>
<p>Chai has a massive collection of 3rd party and vendor specific plugins.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chai.use(chaiHttp);</span><br><span class="line">chai.use(sinonChai);</span><br></pre></td></tr></table></figure>
<h1 id="Chai-and-http-mocks"><a href="#Chai-and-http-mocks" class="headerlink" title="Chai and http mocks"></a>Chai and http mocks</h1><p>Chai HTTP provides an interface for live integration testing web apps using Chai’s chain-able asserts this you test server routes.</p>
</div></header></article></main><footer class="foot"><div class="foot-copy">&copy; 2018 Jonathan Newton</div></footer><script src="/js/scroller.js"></script><script src="/js/main.js"></script></body></html>